config: {}
plugin:

  itchyny/landscape.vim:
    beforeScript: |
      let g:landscape_highlight_todo = 1
      let g:landscape_cursorline = 0
      let g:landscape_vimfiler_important =
              \ ' \%(Dropbox/\|[Dd]ownloads/\|\.vim/\|Library/\|src/\|README\%(\.\%(mk\?d\|rst\)\)\?\>\|'
              \. 'manifest.json\|univ/\|paper/\|js/\|quantum/\|main\.pdf\|miv/\|landscape/\|'
              \. 'lightline/\|lightline-powerful/\|spellbad-pattern/\|calendar/\|thumbnail/\|'
              \. 'dictionary/\|screensaver/\|gitbranch/\|closebuffer/\|external/\|insert-mode-motion/\|'
              \. 'cmdline-ranges/\|cmdline-escape/\|autoft/\|extra-snippets/\|highlighturl/\|extracmd/\|'
              \. 'cursorword/\|unite-preview/\|unite-eject/\|unite-changetime/\|unite-auto-open/\|'
              \. 'winfix/\|qffrom/\|qfedit/\|vicenza/\|adblock-fast/\|2\?bf\/\|maze\/\|cam\/\|mackerel\S*\/\)'
    afterScript: |
      colorscheme landscape
  itchyny/lightline.vim:
    script: |
      exec 'set gfn=' . substitute('Inconsolata for Powerline', ' ', g:iswin ? '_' : '\\ ', 'g') . (g:ismac ? ':h15' : g:iswin ?  ':h13:cANSI' : '\ 12')
      if g:iswin | set gfw=MS_Gothic:h11:cSHIFTJIS | endif
  itchyny/lightline-powerful:
    beforeScript: |
      let g:lightline = {'colorscheme': 'landscape','mode_map':{'c': 'NORMAL'}}
  itchyny/vim-spellbad-pattern:
    script: |
      let g:spellbad_pattern = [ '\<a\ze [aieo]', '^\$', '\~\$\zs\s\+', '\<figure..\?\\', '\\ref{eq:', '^\\end{align}',
            \ '[^\~]\\\(eq\)\?ref\>', 'does not [a-z]*s\>', '\<a [a-z]\+[a-np-rt-wyz]\zss\>', 'in default', '[^,]\zs \ze\$[^$]\{,9\}\$']
  itchyny/calendar.vim:
    mapleader: ","
    command: Calendar
    mapping: <Plug>(calendar)
    script: |
      map <silent> <Leader>z <Plug>(calendar)
    beforeScript: |
      let g:calendar_cache_directory = $CACHE.'/calendar'
      let g:calendar_views = [ 'year', 'month', 'day_3', 'clock' ]
      let g:calendar_google_calendar = 1
      let g:calendar_google_task = 1
  itchyny/thumbnail.vim:
    mapleader: ","
    command: Thumbnail
    mapping: <Plug>(thumbnail)
    script: |
      map <silent> <Leader>t <Plug>(thumbnail)
  itchyny/dictionary.vim:
    mapleader: ","
    command: Dictionary
    mapping: <Plug>(dictionary)
    script: |
      nnoremap <silent> <Leader>y :<C-u>Dictionary -no-duplicate<CR>
    beforeScript: |
      let g:dictionary_executable_path = isdirectory(expand('~/Dropbox/.bin/')) ? '~/Dropbox/.bin/' : '~/.bin/'
    dependon:
      - vimproc
  itchyny/screensaver.vim:
    mapleader: ","
    mapping: <Plug>(screensaver)
    command: ScreenSaver
    script: |
      map <silent> <Leader>s :<C-u>ScreenSaver<CR>
  itchyny/vim-gitbranch:
    {}
  itchyny/vim-closebuffer:
    mapping: <Plug>(closebuffer)
    insert: true
    script: |
      map <C-w> <Plug>(closebuffer)
      imap <C-w> <Plug>(closebuffer)
  itchyny/vim-external:
    mapleader: \
    mappings:
      - <Plug>(external-editor)
      - <Plug>(external-explorer)
      - <Plug>(external-browser)
    script: |
      map <Leader>g <Plug>(external-editor)
      map <Leader>n <Plug>(external-explorer)
      map <Leader>b <Plug>(external-browser)
      map ge <Plug>(external-explorer)
  itchyny/vim-qffrom:
    commands:
      - Qffrom
      - Grep
      - Find
      - Make
      - Vint
    script: |
      nnoremap gr   :<C-u>Grep<Space>
      nnoremap K    :<C-u>Grep <C-r><C-w><CR>
      nnoremap gf   :<C-u>Find<Space>
      nnoremap <F5> :<C-u>Make<CR>
    beforeScript: |
      let g:qffrom = {
            \   '_'   : { 'post': 'leftabove copen' },
            \   'grep': { 'command':
            \             'if git rev-parse >/dev/null 2>&1 && ! <hasdir>; then '
            \           . '  git grep -HIin -- $* "$(git rev-parse --show-toplevel)" 2>/dev/null;'
            \           . 'else '
            \           . substitute( 'grep --exclude-dir=.git --exclude-dir=.svn '
            \           . '--exclude=tags --exclude=\*.{bak,aux,bib,bbl,blg,nav,toc,out,min.js,min.css} --exclude=.histfile\* -HIsinr -- $* <dir>; fi'
            \           , 'exclude-dir', 'exclude' . (has('win32') || has('win64') ? '' : '-dir'), 'g'), 'git_root': 1 },
            \   'find': { 'command': 'find <dir> -name .git -prune -o -type f -iname ''$*'' -print', 'git_root': 1 },
            \   'make': { 'command': 'cd <dir> 2>&1 && '
            \           . 'if test -f Makefile -o -f makefile; then make $* 2>&1; '
            \           . 'elif test -f configure; then ./configure 2>&1 && make 2>&1; '
            \           . 'elif test -f Makefile.am; then autoreconf -i 2>&1 && ./configure 2>&1 && make 2>&1; '
            \           . 'else; make; fi',
            \             'dironly': 1
            \           },
            \   'vint': { 'command': 'vint $*' },
            \ }
      command! -nargs=* Grep Qffrom grep <args>
      command! -nargs=* Find Qffrom find <args>
      command! -nargs=* Make Qffrom make <args>
      command! -nargs=* Vint Qffrom vint <args>
  itchyny/vim-autoft:
    beforeScript: |
      let g:autoft_config = [
            \ { 'filetype': 'html'     , 'pattern': '<\%(!DOCTYPE\|html\|head\|script\)\|^html:5\s*$' },
            \ { 'filetype': 'tex'      , 'pattern': '\\\%(document\|begin\|usepackage\|section\)' },
            \ { 'filetype': 'c'        , 'pattern': '^\s*#\s*\%(include\|define\)\>' },
            \ { 'filetype': 'go'       , 'pattern': '^import (' },
            \ { 'filetype': 'scala'    , 'pattern': '^\%(import\|module\) \%([a-pr-z]\)' },
            \ { 'filetype': 'haskell'  , 'pattern': '^\%(import\|module\) \%([A-Z]\|qualified\)\|main\s*::' },
            \ { 'filetype': 'diff'     , 'pattern': '^diff -' },
            \ { 'filetype': 'sh'       , 'pattern': '^#!.*\%(\<sh\>\|\<bash\>\)\s*$\|if [ -' },
            \ { 'filetype': 'hatena'   , 'pattern': '^\%(>|[a-z]\+|\|||<\)$\|^*\[[a-z]\+]' },
            \ { 'filetype': 'vim'      , 'pattern': '\%(^{\|\<\%(let\|set\|autocmd\) \)\|noremap\|g:loaded_\|&l:\|(g:,\|^Called *\d\+ *times$' },
            \ { 'filetype': 'css'      , 'pattern': '^\%(html\|body\)\%(, *\%([a-z]\+\)\)* *{' },
            \ { 'filetype': 'markdown' , 'pattern': '^# $' },
            \ ]
  itchyny/vim-extracmd:
    afterScript: |
      call extracmd#set('a[ppend]', '')
      call extracmd#set('i[nsert]', '')
      call extracmd#set('<silent>', 'vp[s]'  , 'vsp')
      call extracmd#set('<silent>', 'q1'     , 'q!')
      call extracmd#set('<silent>', 'qa1'    , 'qa!')
      call extracmd#set('sil[ent]1', 'silent!')
      call extracmd#set('<silent>', 'nvew'   , 'vnew')
      call extracmd#set('<silent>', 'w!!'    , 'w !sudo tee > /dev/null %')
      call extracmd#set('<silent>', 'make'   , 'silent! make')
      call extracmd#set('<silent>', 'syn'    , 'echo synIDattr(synID(line(''.''), col(''.''), 0), ''name'')')
      call extracmd#set('<silent>', 'pro[fil]', 'profile start profile.log <bar> profile func *')
      call extracmd#set('<silent>', 'rof'    , 'profile start profile.log <bar> profile func *')
      call extracmd#set('<silent>', 'rtp'    , 'if !get(b:,''rtp'')<bar>vne<bar>en<bar>let b:rtp=1<bar>sil!%d_<bar>0put=split(&rtp, '','')<bar>setl bt=nofile bh=wipe noswf nobl<bar>diffu')
      call extracmd#set('<silent>', 'scr[iptnames]', 'if !get(b:,''s'')<bar>vne<bar>en<bar>redi=>b:s<bar>sil!scrip<bar>redi end<bar>sil!%d_<bar>sil0put=b:s<bar>sil!1d_<bar>setl bt=nofile bh=wipe noswf nobl<bar>diffu')
      call extracmd#set('<silent>', 'gd'     , 'if len(gitbranch#name())<bar>if (!get(b:,''gd''))*((&ft!='''')+(&mod)+(bufname('''')!=''''))<bar>vne<bar>en<bar>let b:gd=1<bar>sil!%d_<bar>setl bt=nofile bh=wipe noswf nobl nowrap ft=diff<bar>sil!0put=system(''git diff'')<bar>sil!$d_<bar>sil!1<bar>el<bar>redr<bar>en<bar>echo''git diff''')
      call extracmd#set('<silent>', 'aoff'   , 'AutodateOFF')
      call extracmd#set('<silent>', 'aon'    , 'AutodateON')
      call extracmd#set('<silent>', '[a]git' , 'Agit')
      call extracmd#set('<silent>', 'bc'     , 'Calc')
      call extracmd#set('<silent>', 'gh'     , 'GHD!')
      call extracmd#set('<silent>', 'ga'     , 'GHA!')
      call extracmd#set('<silent>', 'cal[endar]', 'Calendar -position=topleft -split=vertical -width=27 -view=year')
      call extracmd#set('<silent>', 'date'   , 'echo strftime("%x (%a) %X")')
      call extracmd#set('<silent>', 'di'     , 'Dictionary -cursor-word -no-duplicate')
      call extracmd#set('<silent>', 'lin'    , 'silent! call vimlint#vimlint(expand("%"), {"output": "quickfix"}) <bar> leftabove copen')
      call extracmd#set('<silent>', 'lint'   , 'silent! call vimlint#vimlint(".", {"output": "quickfix"}) <bar> leftabove copen')
  itchyny/vim-qfedit:
    filetype: qf
  itchyny/vim-winfix:
    {}
  itchyny/vim-cursorword:
    afterScript: |
      augroup cursorword-filetype
        autocmd!
        autocmd FileType qf,unite,vimfiler,vimshell,thumbnail,vimcalc,quickrun,calendar,github-dashboard let b:cursorword = 0
      augroup END
  itchyny/vim-highlighturl:
    {}
  itchyny/vim-insert-mode-motion:
    insert: true
  itchyny/vim-cmdline-ranges:
    {}
  itchyny/vim-cmdline-escape:
    {}
  itchyny/vim-extra-snippets:
    {}
  itchyny/vim-haskell-indent:
    filetype: haskell
  itchyny/vim-pdf:
    filetype: pdf

  Shougo/neocomplete.vim:
    enable: has('lua') && v:version > 703
    beforeScript: |
      let g:neocomplete#enable_at_startup = 1
      let g:neocomplete#enable_smart_case = 1
      let g:neocomplete#max_list = 1000
      let g:neocomplete#skip_auto_completion_time = '0.20'
      let g:neocomplete#auto_completion_start_length = 1
      let g:neocomplete#data_directory = '~/.cache/neocomplete'
      let g:neocomplete#force_overwrite_completefunc = 1
      let g:neocomplete#ignore_source_files = [ 'member.vim', 'tag.vim', 'dictionary.vim', 'include.vim', 'file_include.vim' ]
      let g:neocomplete#force_omni_input_patterns = get(g:, 'neocomplete#force_omni_input_patterns', {})
      let g:neocomplete#force_omni_input_patterns.python = '\%([^. \t]\.\|^\s*@\|^\s*from\s.\+import \|^\s*from \|^\s*import \)\w*'
      let g:neocomplete#force_omni_input_patterns.haskell = '[A-Z][a-z]*\.\w*\|import.*'
      let g:neocomplete#sources#omni#input_patterns = get(g:, 'neocomplete#sources#omni#input_patterns', {})
      let g:neocomplete#sources#omni#input_patterns.javascript = '[[:alpha:]./"''$]\+'
      let g:neocomplete#sources#omni#input_patterns.coffee = '[[:alpha:]./"''$]\+'
      let g:neocomplete#sources#omni#input_patterns.typescript = '[[:alpha:]./"''$]\+'
      let g:neocomplete#sources#omni#input_patterns.haskell = 'import\s\+.*\|[:alpha:]\.\w*'
      let g:neocomplete#sources#omni#input_patterns.pdf = '[-/%a-zA-Z0-9_]\+'
    afterScript: |
      call neocomplete#custom#source('omni', 'rank', 7)
      call neocomplete#custom#source('omni', 'converters', ['converter_remove_last_paren'])
      call neocomplete#custom#source('look', 'min_pattern_length', 3)
      inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
      inoremap <expr><BS>  neocomplete#smart_close_popup()."\<BS>"
      inoremap <expr><CR>  neocomplete#close_popup() . "\<CR>"
  Shougo/neosnippet:
    script: |
      let g:neosnippet#snippets_directory = [ expand((isdirectory(expand('~/Dropbox/.vim/miv')) ? '~/Dropbox' : '~') . '/.vim/miv/extra-snippets/snippets'),
              \ expand((isdirectory(expand('~/Dropbox/.vim/miv')) ? '~/Dropbox' : '~') . '/.vim/miv/scala-vim-snippets') ]
      imap <expr><TAB> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? "\<C-n>" : "\<TAB>"
      smap <expr><TAB> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
      imap <expr><C-o> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<ESC>o"
      let g:neosnippet#scope_aliases = { 'typescript': 'javascript' }
  Shougo/neosnippet-snippets: {}
  thinca/vim-quickrun:
    command: QuickRun
    mapping: <Plug>(quickrun)
    mapleader: \
    dependon:
      - vimproc
    beforeScript: |
      let g:quickrun_config = {'_': {'runner': 'vimproc', 'runner/vimproc/updatetime': 200, 'split': 'vertical', 'into': 1}}
      for [s:ft, s:exe] in [['quickrun', 'cat'], ['javascript', 'node'], ['roy', 'roy'], ['qcl', 'qcl'], ['brainfuck', 'bf'], ['text', 'cat']]
        let g:quickrun_config[s:ft] = {'command': s:exe}
      endfor
      let g:quickrun_config.markdown = {'type' : 'markdown/pandoc', 'outputter': 'browser', 'cmdopt': '-s'}
      let g:quickrun_config.rst = {'command' : 'pandoc', 'exec': '%c --from=rst --to=html %o %s %a', 'outputter': 'browser', 'cmdopt': '-s'}
      let g:quickrun_config.tex = {'command' : executable('autolatex') ? 'autolatex' : executable('platex') ? 'platex' : ''}
      let g:quickrun_config.latex = g:quickrun_config.tex
      let g:quickrun_config.nroff = {'command': 'man', 'args': " -P cat | tr '\b' '\1' | sed -e 's/.\1//g'", 'filetype': 'man'}
      let g:quickrun_config.gnuplot = {'command' : executable('autognuplot') ? 'autognuplot' : executable('gnuplot') ? 'gnuplot' : ''}
      let g:quickrun_config.objc = {'command': 'cc', 'exec': ['%c %s -o %s:p:r -framework Foundation', '%s:p:r %a'], 'tempfile': '{tempname()}.m', 'hook/sweep/files': '%s:p:r'}
      let g:quickrun_config.dot = {'command' : 'dot', 'exec': ['%c -Tpng %s -o %s:p:r.png', (executable('gnome-open') ? 'gnome-open' : 'open') . ' %s:p:r.png'] }
      let g:quickrun_config.spice = {'command': 'scad3.exe', 'exec': ['%c -b %s:t'] }
      let g:quickrun_config.abc = {'command': 'abcm2ps', 'exec': extend(['%c %s -O %s:p:r.ps', 'ps2pdf %s:p:r.ps', 'open %s:p:r.pdf'], executable('abc2midi') ? ['abc2midi %s -o %s:p:r.mid', 'open %s:p:r.mid'] : [])}
    script: |
      nnoremap <expr> <C-c> exists('*quickrun#is_running') && quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"
      nnoremap <silent> <Leader>r :<C-u>call <SID>quickrun(0, 0)<CR>
      nnoremap <silent> <Leader>e :<C-u>call <SID>quickrun(1, 0)<CR>
      nnoremap <silent> <Leader>o :<C-u>call <SID>quickrun(1, 1)<CR>
      function! s:quickrun(input, output)
        let bufname = '-outputter/buffer/name ' . string( '[quickrun output'. (tabpagenr() > 1 ? ' ' . tabpagenr() : '') . ']' )
        let name = matchstr(expand('%:t'), '.*\ze\.')
        let out = a:output ? '>file:' . name . 'o' : ''
        let infile = name . 'i'
        let in = a:input ? (filereadable(infile) ? '<' . infile : filereadable('i') ? '<i' : '') : ''
        execute 'QuickRun' bufname in out
      endfunction
  ujihisa/neco-look:
    enable: executable('look')

  Shougo/vimfiler:
    mapleader: \
    commands:
      - VimFiler
      - VimFilerBufferDir
    dependon:
      - vimproc
      - unite
    beforeScript: |
      let g:vimfiler_as_default_explorer = 1
      let g:vimfiler_sort_type = 'TIME'
      let g:vimfiler_safe_mode_by_default = 0
      let g:vimfiler_force_overwrite_statusline = 0
      let g:vimfiler_restore_alternate_file = 0
      let g:vimfiler_data_directory = $CACHE.'/vimfiler'
      let g:vimfiler_detect_drives = []
      let g:vimfiler_min_cache_files = 10000000000
      let g:vimfiler_ignore_pattern = '^\.\%([^v]\|v[^i]\|vi[^m]\)\|\.\%(o\|hi\|bak\|pyc\|aux\|bbl\|blg\|dvi\|nav\|snm\|toc\|out\)$\|^dist$\|^\%(score\|font\|tex\|graphviz\|scheme\|ANTLER\|pl\|old_project\|kmc\|py\|rst\|eclipse\|rubik\|coq\|r\|antlr\|ltspice\)$\|conflicted copy\|競合コピー'
      let g:vimfiler_tree_leaf_icon = ' '
      let g:vimfiler_tree_opened_icon = '▾'
      let g:vimfiler_tree_closed_icon = '▸'
      let g:vimfiler_file_icon = '-'
      let g:vimfiler_readonly_file_icon = '✗'
      let g:vimfiler_marked_file_icon = '✓'
      let g:vimfiler_execute_file_list = {'jpg': 'open', 'jpeg': 'open', 'gif': 'open', 'bmp': 'open', 'html': 'open', 'ppt': 'open', 'pdf': 'open', 'png': 'open', 'ico': 'open'}
    script: |
      nnoremap <silent> <Leader>f :<C-u>VimFilerBufferDir -status -buffer-name=vimfiler<C-r>=tabpagenr()<CR> -auto-cd<CR>
      nnoremap <silent> <Leader><Leader> :<C-u>VimFilerBufferDir -status -buffer-name=vimfiler<C-r>=tabpagenr()<CR> -auto-cd<CR>
  Shougo/vinarise.vim:
    mapleader: \
    loadbefore:
      - vimfiler
    commands:
      - Vinarise
  Shougo/unite.vim:
    commands:
      - Unite
    mapleader: ","
    function: unite
    beforeScript: |
      let g:unite_force_overwrite_statusline = 0
      let g:unite_data_directory = $CACHE.'/unite'
      let g:unite_source_grep_max_candidates = 500
      let g:unite_source_find_max_candidates = 500
    afterScript: |
      call unite#custom#profile('default', 'context', {
            \ 'start_insert' : 1,
            \ 'prompt_direction': 'top',
            \ 'prompt': g:fancy ? '❯ ' : '> ',
            \ 'candidate_icon': g:fancy ? '▸ ' : '- ',
            \ 'marked_icon': g:fancy ? '* ' : '* ',
            \ 'hide_icon': 0 })
    dependedby:
      - unite-build
      - unite-colorscheme
      - unite-highlight
      - unite-haddock
      - unite-outline
      - unite-haskellimport
      - unite-webcolorname
      - unite-auto-open
      - unite-changetime
      - unite-preview
  Shougo/unite-build:
    loadafter:
      - unite
  ujihisa/unite-colorscheme:
    loadafter:
      - unite
  osyo-manga/unite-highlight:
    loadafter:
      - unite
  eagletmt/unite-haddock:
    loadafter:
      - unite
    mapleader: ","
    enable: executable('hoogle')
    script: |
      nnoremap <silent> <Leader>h :<C-u>Unite hoogle -buffer-name=hoogle<CR>
  Shougo/unite-outline:
    loadafter:
      - unite
  ujihisa/unite-haskellimport:
    mapleader: ","
    loadafter:
      - unite
    script: |
      nnoremap <silent> <Leader>p :<C-u>Unite haskellimport -buffer-name=haskellimport<CR>
  pasela/unite-webcolorname:
    loadafter:
      - unite
  itchyny/unite-eject:
    enable: "0"
    loadafter:
      - unite
  itchyny/unite-auto-open:
    loadafter:
      - unite
    afterScript: |
      call unite#custom_default_action('file', 'auto_open')
  itchyny/unite-changetime:
    loadafter:
      - unite
  itchyny/unite-preview:
    loadafter:
      - unite

  Shougo/vimshell.vim:
    commands:
      - VimShell
      - VimShellPop
      - VimShellBufferDir
    function: vimshell
    dependon:
      - vimproc
    beforeScript: |
      let g:vimshell_interactive_update_time = 150
      let g:vimshell_popup_command = 'top new'
      let g:vimshell_split_command = 'vsplit'
      let g:vimshell_prompt_expr = 'escape(fnamemodify(getcwd(), ":~"), "\\[]()?! ")." "'
      let g:vimshell_prompt_pattern = (has('win16') || has('win32') || has('win64') ? '\%(^\f:\\*' : '\%(^\~\?/') . '\%([[:alpha:].]\%(\f\|\\.\)*\)\? \|^[*a-zA-Z][a-zA-Z .0-9]\+> \|^>>> \)'
      let g:vimshell_scrollback_limit = 1000000000
      let g:vimshell_disable_escape_highlight = 0
      let g:vimshell_force_overwrite_statusline = 0
      let g:vimshell_temporary_directory = $CACHE.'/vimshell'
      let g:vimshell_max_command_history = 1000000
      let g:vimshell_vimshrc_path = isdirectory(expand('~/Dropbox/.files/')) ? expand('~/Dropbox/.files/.vimshrc') : expand('~/.files/.vimshrc')
    script: |
      nnoremap <silent> H :<C-u>VimShellBufferDir -popup<CR>
      nnoremap <silent> s :<C-u>VimShellBufferDir<CR>
      nnoremap <silent> S :<C-u>VimShellBufferDir -split<CR>

  Align:
    command: Align
  zef/vim-cycle:
    mappings:
      - <Plug>CycleNext
      - <Plug>CyclePrevious
    script: |
      nmap <C-a> <Plug>CycleNext
      nmap <C-x> <Plug>CyclePrevious
      nmap + <Plug>CycleNext
      nmap - <Plug>CyclePrevious
  VimCalc:
    command: Calc
    mapleader: ","
    enable: has('python')
    script: |
      nnoremap <silent> <Leader>a :<C-u>Calc<CR>
  sjl/gundo.vim:
    mapleader: ","
    command: GundoToggle
    enable: has('python')
  majutsushi/tagbar:
    commands:
      - Tagbar
      - TagbarToggle
    beforeScript: |
      let g:tagbar_sort = 0
      let g:tagbar_autofocus = 1
      let g:tagbar_show_linenumbers = 1
      let g:tagbar_compact = 1
      let g:tagbar_sort = 0
  xterm-color-table.vim:
    command: XtermColorTable
  thinca/vim-scouter:
    command: Scouter
  thinca/vim-prettyprint:
    commands:
      - PrettyPrint
      - PP
  thinca/vim-visualstar:
    mappings:
      - <Plug>(visualstar-*)
      - <Plug>(visualstar-#)
    script: |
      let g:visualstar_no_default_key_mappings = 1
      xmap <silent> * <Plug>(visualstar-*):<C-u>set hlsearch<CR>
      xmap <silent> # <Plug>(visualstar-#):<C-u>set hlsearch<CR>
  tyru/capture.vim:
    command: Capture
  ctrlpvim/ctrlp.vim:
    commands:
      - CtrlP
      - CtrlPMRUFiles
      - CtrlPCurFile
      - CtrlPLine
    script: |
      nnoremap <silent><C-p> :<C-u>CtrlPMRUFiles<CR>
      nnoremap <silent><C-o> :<C-u>CtrlPCurFile<CR>
      nnoremap <silent><S-l> :<C-u>CtrlPLine<CR>
    beforeScript: |
      let g:ctrlp_cmd = 'CtrlPMRUFiles'
      let g:ctrlp_show_hidden = 1
      let g:ctrlp_max_depth = 5
      let g:ctrlp_max_files = 300
      let g:ctrlp_mruf_max = 300
      let g:ctrlp_custom_ignore = { 'dir': '\v[\/]\.(git|hg|svn)$', 'file': '\v\.(exe|so|dll|swp|pdf|DS_Store)$', }
      let g:ctrlp_open_new_file = 'r'
      let g:ctrlp_use_caching = 1
      let g:ctrlp_clear_cache_on_exit = 0
      let g:ctrlp_cache_dir = $CACHE.'/ctrlp'
      let s:_ctrlp_cache = g:ctrlp_cache_dir . '/mru/cache.txt'

  junegunn/vim-github-dashboard:
    commands:
      - GHD
      - GHA
    beforeScript: |
      let g:github_dashboard = {
          \ 'emoji': 0,
          \ 'statusline': 0,
          \ 'username': 'itchyny' }
  tpope/vim-surround:
    mappings:
      - <Plug>Dsurround
      - <Plug>Csurround
      - <Plug>Ysurround
      - <Plug>VSurround
    script: |
      nmap ds <Plug>Dsurround
      nmap cs <Plug>Csurround
      vmap S <Plug>VSurround
    beforeScript: |
      let g:surround_{char2nr('$')} = "$\r$"
  tomtom/tcomment_vim:
    command: TComment
    mapping: <Plug>TComment-gc
    function: tcomment
    script: |
      nnoremap <silent> __ :TComment<CR>
      vnoremap <silent> __ :TComment<CR>
      nmap <silent> gc <Plug>TComment-gc
    beforeScript: |
      let g:tcommentMapLeader1 = ''
      let g:tcommentMapLeader2 = ''
  autodate.vim:
    beforeScript: |
      let g:autodate_format = '%Y/%m/%d %H:%M:%S'
  gregsexton/MatchTag: {}
  matchit.zip: {}

  eagletmt/ghci-vim:
    filetype: haskell
    enable: executable('ghc')
    commands:
      - GhciQuit
      - GhciType
      - GhciInfo
      - GhciLoad
      - GhciModule
      - GhciSend
  eagletmt/ghcmod-vim:
    filetype: haskell
    enable: executable('ghc') && executable('ghc-mod')
    dependon:
      - vimproc
  eagletmt/neco-ghc:
    filetype: haskell
    enable: executable('ghc') && executable('ghc-mod')
    beforeScript: |
      let g:necoghc_enable_detailed_browse = 1

  cohama/agit.vim:
    mapleader: ","
    commands:
      - Agit
      - AgitFile
    beforeScript: |
      let g:agit_enable_auto_refresh = 1
    script: |
      nnoremap <silent> <Leader>g :<C-u>Agit<CR>:silent! 3wincmd w<CR>
  mattn/gist-vim:
    command: Gist
    dependon:
      - webapi
  mattn/webapi-vim:
    loadbefore:
      - gist
      - emmet
  ynkdir/vim-vimlparser:
    loadbefore:
      - vimlint
    dependedby:
      - vimlint
  syngan/vim-vimlint:
    function: vimlint
    dependon:
      - vimlparser
  scrooloose/syntastic:
    filetypes:
      - c
      - cpp
      - haskell
      - sh
    beforeScript: |
      let g:syntastic_mode_map = { 'mode': 'passive' }
      let g:syntastic_echo_current_error = 0
      let g:syntastic_enable_highlighting = 0
    script: |
      augroup auto-syntastic
        autocmd!
        autocmd BufWritePost *.c,*.cpp,*.hs call s:syntastic()
      augroup END
      function! s:syntastic()
        if exists(':SyntasticCheck') | exec 'SyntasticCheck' | endif
        if exists('*lightline#update') | call lightline#update() | endif
      endfunction
  Shougo/vimproc.vim:
    build: make
    function: vimproc
    loadbefore:
      - ghcmod
      - vimfiler
      - vimshell
      - quickrun
      - dictionary
  thinca/vim-themis:
    function: themis
  vim-jp/vital.vim:
    enable: "0"

  kana/vim-textobj-user: {}
  kana/vim-textobj-entire:
    dependon:
      - textobj-user
    mapmodes:
      - o
      - v
    mappings:
      - <Plug>(textobj-entire-a)
      - <Plug>(textobj-entire-i)
      - ie
      - ae
  kana/vim-textobj-line:
    dependon:
      - textobj-user
    mapmodes:
      - o
      - v
    mappings:
      - <Plug>(textobj-line-a)
      - <Plug>(textobj-line-i)
      - il
      - al
  kana/vim-textobj-function:
    dependon:
      - textobj-user
    mapmodes:
      - o
      - v
    mappings:
      - <Plug>(textobj-function-a)
      - <Plug>(textobj-function-i)
      - <Plug>(textobj-function-A)
      - <Plug>(textobj-function-I)
      - if
      - af
      - iF
      - aF
  kana/vim-textobj-indent:
    dependon:
      - textobj-user
    mapmodes:
      - o
      - v
    mappings:
      - <Plug>(textobj-indent-a)
      - <Plug>(textobj-indent-i)
      - <Plug>(textobj-indent-A)
      - <Plug>(textobj-indent-I)
      - ii
      - ai
      - iI
      - aI
  kana/vim-textobj-underscore:
    dependon:
      - textobj-user
    mapmodes:
      - o
      - v
    mappings:
      - <Plug>(textobj-underscore-a)
      - <Plug>(textobj-underscore-i)
      - i_
      - a_
  glts/vim-textobj-comment:
    dependon:
      - textobj-user
    mapmodes:
      - o
      - v
    mappings:
      - <Plug>(textobj-comment-a)
      - <Plug>(textobj-comment-i)
      - <Plug>(textobj-comment-big-a)
      - <Plug>(textobj-comment-big-i)
      - ic
      - ac
      - iC
      - aC
  osyo-manga/vim-textobj-multiblock:
    dependon:
      - textobj-user
    mapmodes:
      - o
      - v
    mappings:
      - <Plug>(textobj-multiblock-a)
      - <Plug>(textobj-multiblock-i)
    beforeScript: |
      let g:textobj_multiblock_no_default_key_mappings = 1
      let g:textobj_multiblock_blocks = [
            \ [ '(', ')', 1 ],
            \ [ '[', ']', 1 ],
            \ [ '{', '}', 1 ],
            \ [ '<', '>', 1 ],
            \ [ '"', '"', 1 ],
            \ [ "'", "'", 1 ],
            \ ]
  osyo-manga/vim-textobj-multitextobj:
    dependon:
      - textobj-user
      - textobj-multiblock
      - textobj-comment
      - textobj-indent
      - textobj-function
      - textobj-entire
    mapmodes:
      - o
      - v
    mappings:
      - <Plug>(textobj-multitextobj-a)
      - <Plug>(textobj-multitextobj-i)
    beforeScript: |
      let g:textobj_multitextobj_textobjects_i = [
            \   { 'textobj': "\<Plug>(textobj-multiblock-i)", 'is_cursor_in': 1 },
            \   { 'textobj': "\<Plug>(textobj-comment-i)", 'is_cursor_in': 1 },
            \   { 'textobj': "\<Plug>(textobj-indent-i)", 'is_cursor_in': 1 },
            \   { 'textobj': "\<Plug>(textobj-function-i)", 'is_cursor_in': 1 },
            \   "\<Plug>(textobj-entire-i)",
            \ ]
    script: |
      omap a<CR> <Plug>(textobj-multitextobj-a)
      omap i<CR> <Plug>(textobj-multitextobj-i)
      omap <CR> <Plug>(textobj-multitextobj-i)
      xmap a<CR> <Plug>(textobj-multitextobj-a)
      xmap i<CR> <Plug>(textobj-multitextobj-i)
      xmap <CR> <Plug>(textobj-multitextobj-i)
  thinca/vim-textobj-between:
    dependon:
      - textobj-user
    mapmodes:
      - o
      - v
    mappings:
      - <Plug>(textobj-between-a)
      - <Plug>(textobj-between-i)
    beforeScript: |
      let g:textobj_between_no_default_key_mappings = 1
      omap ib <Plug>(textobj-between-i)
      omap ab <Plug>(textobj-between-a)
      vmap ib <Plug>(textobj-between-i)
      vmap ab <Plug>(textobj-between-a)

  kana/vim-operator-user: {}
  kana/vim-operator-replace:
    dependon:
      - operator-user
    beforeScript: |
      nmap [  <Plug>(operator-replace)

  motemen/hatena-vim:
    filetype: hatena
  elzr/vim-json:
    filetype: json
  html5.vim:
    filetype: html
  mattn/emmet-vim:
    filetypes:
      - html
      - haml
      - jade
      - slim
      - css
      - less
      - sass
      - scss
    dependon:
      - webapi
    beforeScript: |
      let g:user_emmet_settings = { 'indentation' : '  ' }
    afterScript: |
      imap <expr><silent> <Plug>(neosnippet-emmet-supertab) neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : emmet#isExpandable() ? "\<Plug>(emmet-expand-abbr)" : pumvisible() ? "\<C-n>" : "\<Tab>"
      imap <expr><silent> <Plug>(emmet-supertab) emmet#isExpandable() ? "\<Plug>(emmet-expand-abbr)" : pumvisible() ? "\<C-n>" : "\<Tab>"
  wavded/vim-stylus:
    filetype: stylus
  groenewege/vim-less:
    filetype: less
  tpope/vim-haml:
    filetype: haml
  syntaxm4.vim:
    filetype: m4
  jade.vim:
    filetype: jade
  slim-template/vim-slim:
    filetype: slim
  kchmck/vim-coffee-script:
    filetype: coffee
  mintplant/vim-literate-coffeescript:
    dependon:
      - coffee-script
    filetype: litcoffee
  briancollins/vim-jst:
    filetype: jst
  rest.vim:
    filetype: rest
  tpope/vim-markdown:
    filetype: markdown
  davidhalter/jedi-vim:
    filetype: python
    beforeScript: |
      let g:jedi#auto_vim_configuration = 0
      let g:jedi#popup_select_first = 0
      let g:jedi#completions_enabled = 0
  itspriddle/vim-javascript-indent:
    filetype: javascript
  1995eaton/vim-better-javascript-completion:
    filetypes:
      - javascript
      - coffee
      - typescript
    beforeScript: |
      let g:vimjs#casesensistive = 1
      let g:vimjs#chromeapis = 1
      let g:vimjs#smartcomplete = 1
  leafgarland/typescript-vim:
    filetype: typescript
  derekwyatt/vim-scala:
    filetype: scala
  tommorris/scala-vim-snippets:
    filetype: scala
  fatih/vim-go:
    filetype: go

beforeScript: |
  let g:iswin = has('win16') || has('win32') || has('win64')
  let g:ismac = !g:iswin && !has('win32unix') && (has('mac') || has('macunix') || has('guimacvim'))
  let g:fancy = g:ismac && has('multi_byte')

  let g:loaded_2html_plugin = 1
  let g:loaded_rrhelper = 1
  let g:loaded_getscriptPlugin = 1
  let g:loaded_vimballPlugin = 1

  let g:hs_highlight_boolean = 1
  let g:hs_highlight_types = 1
  let g:hs_highlight_more_types = 1

  let g:is_bash = 1
  let g:tex_isk = '48-57,92,a-z,A-Z,192-255'
  let g:tex_conceal=''
  let g:tex_indent_items = 0

  if v:version < 700
    finish
  endif

  command -nargs=* Codeforces call s:codeforces(<f-args>)
  function! s:codeforces(...) abort
    if a:0 < 2
      return
    endif
    let dir = expand(printf('~/Dropbox/procon/codeforces/%04d/', a:1))
    silent! call mkdir(dir)
    edit `=dir . tolower(a:2) . '.hs'`
    vnew `=dir . tolower(a:2) . 'i'`
  endfunction

afterScript: |
  let g:mapleader = ','

filetypeScript:
  vim: |
    setlocal foldmethod=marker
    cnoremap <buffer><expr> <C-r><C-w> <SID>word()
    function! s:word()
      let m = "\<C-r>\<C-w>"
      let s = synIDattr(synID(line('.'), col('.'), 0), 'name')
      return s ==# 'vimOption' ? "'".m."'" : s =~# 'vim\%(Command\|Map\>\|Let\|AugroupKey\|AutoCmd\>\|FTCmd\|NotFunc\)' ? ':'.m : s =~# 'vimFuncName' ? m.'()' : m
    endfunction
    if bufname('%') ==# '[Command Line]'
      setlocal nowrap
    endif
  qf: |
    nnoremap <buffer><silent> q     :<C-u>try<bar>wincmd p<bar>cclose<bar>catch<bar>enew<bar>endtry<CR>
    nnoremap <buffer><silent> <CR>  :<C-u>call <SID>qfenter('wincmd p')<CR>
    nnoremap <buffer><silent> <C-t> :<C-u>call <SID>qfenter('tabnew')<CR>
    nnoremap <buffer><silent> <C-n> :<C-u>call <SID>qfenter('wincmd p <bar> new')<CR>
    nnoremap <buffer><silent> <C-v> :<C-u>call <SID>qfenter('wincmd p <bar> vnew')<CR>
    nnoremap <buffer><silent> <C-h> :<C-u>call <SID>qfenter('wincmd p <bar> wincmd h')<CR>
    nnoremap <buffer><silent> <C-l> :<C-u>call <SID>qfenter('wincmd p <bar> wincmd l')<CR>
    function! s:qfenter(cmd)
      let lnum = line('.')
      silent! execute a:cmd
      silent! execute 'cc' lnum
    endfunction
  c: |
    setlocal ofu=ccomplete#Complete
  html: |
    setlocal ofu=htmlcomplete#CompleteTags
    imap <buffer> <Tab> <Plug>(neosnippet-emmet-supertab)
    imap <buffer> <C-g> <Plug>(emmet-supertab)
  css: |
    setlocal ofu=csscomplete#CompleteCSS
    setlocal iskeyword=37,45,48-57,95,a-z,A-Z,192-255
    imap <buffer> <Tab> <Plug>(neosnippet-emmet-supertab)
    imap <buffer> <C-g> <Plug>(emmet-supertab)
  haml: |
    imap <buffer> <Tab> <Plug>(neosnippet-emmet-supertab)
    imap <buffer> <C-g> <Plug>(emmet-supertab)
  jade: |
    imap <buffer> <Tab> <Plug>(neosnippet-emmet-supertab)
    imap <buffer> <C-g> <Plug>(emmet-supertab)
  slim: |
    imap <buffer> <Tab> <Plug>(neosnippet-emmet-supertab)
    imap <buffer> <C-g> <Plug>(emmet-supertab)
  less: |
    imap <buffer> <Tab> <Plug>(neosnippet-emmet-supertab)
    imap <buffer> <C-g> <Plug>(emmet-supertab)
  sass: |
    imap <buffer> <Tab> <Plug>(neosnippet-emmet-supertab)
    imap <buffer> <C-g> <Plug>(emmet-supertab)
  scss: |
    imap <buffer> <Tab> <Plug>(neosnippet-emmet-supertab)
    imap <buffer> <C-g> <Plug>(emmet-supertab)
  javascript: |
    setlocal ofu=js#CompleteJS
  coffee: |
    setlocal ofu=js#CompleteJS nospell
  typescript: |
    setlocal ofu=js#CompleteJS nospell
    imap <expr><buffer> <Tab> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? "\<C-n>" : "\<TAB>"
  php: |
    setlocal ofu=phpcomplete#CompletePHP
  xml: |
    setlocal ofu=xmlcomplete#CompleteTags
  python: |
    setlocal ofu=jedi#completions
  make: |
    setlocal noexpandtab
  sh: |
    setlocal iskeyword=36,45,48-57,64,95,a-z,A-Z,192-255
  tex: |
    setlocal nosmartindent noautoindent
    execute 'setlocal ' . (search("[^\x01-\x7e]", 'n') == 0 && line('$') > 5 ? '' : 'no') . 'spell'
  markdown: |
    setlocal nosmartindent noautoindent
    execute 'setlocal ' . (search("[^\x01-\x7e]", 'n') == 0 && line('$') > 5 ? '' : 'no') . 'spell'
  hatena: |
    setlocal nosmartindent noautoindent
  dictionary: |
    nmap <buffer> <C-@> <Plug>(dictionary_jump_back)
  unite: |
    inoremap <silent> <buffer> <C-z> <Nop>
    inoremap <silent> <buffer> <C-o> <Nop>
    nmap <buffer> <C-a> <Plug>(unite_insert_enter)
    nmap <buffer> <BS> <Plug>(unite_exit)
  vimfiler: |
    nunmap <buffer> <C-l>
    nunmap <buffer> \
    nunmap <buffer> gr
    nunmap <buffer> gf
    nnoremap <buffer> <C-l> <ESC><C-w>l
    nmap <buffer> <C-r> <Plug>(vimfiler_redraw_screen)
    nmap <buffer> o <Plug>(vimfiler_sync_with_current_vimfiler)
    nmap <buffer> O <Plug>(vimfiler_sync_with_current_vimfiler)
    nmap <buffer><silent><expr> <CR> vimfiler#smart_cursor_map("\<Plug>(vimfiler_cd_file)", vimfiler#get_filename() =~? '\.\(exe\\|png\\|gif\\|jpe\?g\\|pdf\)$' ? "\<Plug>(vimfiler_execute_system_associated)" : "\<Plug>(vimfiler_edit_file)")
    nmap <buffer><silent> l <CR>
    nmap <buffer><expr> e vimfiler#smart_cursor_map("\<Plug>(vimfiler_cd_file)", "\<Plug>(vimfiler_edit_file)")
    nnoremap <buffer><silent> t :<C-u>call vimfiler#mappings#do_action('change_time')<CR>
    silent! call delete("Icon\r")
    silent! call delete('.DS_Store')
  vimshell: |
    iunmap <buffer> <C-h>
    iunmap <buffer> <C-k>
    iunmap <buffer> <C-l>
    iunmap <buffer> <C-w>
    nunmap <buffer> <C-k>
    nunmap <buffer> <C-l>
    nnoremap <buffer> <C-a> <Nop>
    nnoremap <buffer> <C-m> <ESC><C-w>j
    inoremap <buffer> <C-h> <ESC><C-w>h
    inoremap <buffer> <C-j> <ESC><C-w>j
    inoremap <buffer> <C-k> <ESC><C-w>k
    inoremap <buffer> <C-l> <ESC><C-w>l
    inoremap <silent><buffer> ^ <ESC>:call vimshell#execute('cd ../')<CR>:call vimshell#print_prompt()<CR>:call vimshell#start_insert()<CR>
    inoremap <buffer> <C-^> <ESC><C-^>
    imap <buffer> <C-g> <Plug>(vimshell_history_neocomplete)<C-n>
    imap <buffer> <Up> <ESC>GA<Plug>(vimshell_history_unite)
    nmap <buffer> <Up> GA<Plug>(vimshell_history_unite)
    imap <buffer> <Down> <ESC>GA<Plug>(vimshell_history_unite)
    nmap <buffer> <Down> GA<Plug>(vimshell_history_unite)
    setlocal nonumber synmaxcol=10000
  agit: |
    nmap <buffer> <C-r> <Plug>(agit-reload)
    nunmap <buffer> <C-k>
    nunmap <buffer> <C-j>
    nunmap <buffer> <C-m>
  agit_diff: |
    nmap <buffer> <C-r> <Plug>(agit-reload)
  agit_stat: |
    nmap <buffer> <C-r> <Plug>(agit-reload)
  thumbnail: |
    let b:highlighturl_enable = 0
  calendar: |
    nunmap <buffer> <C-h>
    nunmap <buffer> <C-l>
  vimcalc: |
    setlocal nonumber
  quickrun: |
    setlocal nonumber tabstop=8 nolist
  cam: |
    setlocal nonumber synmaxcol=10000
  haskell: |
    setlocal ofu=necoghc#omnifunc
    setlocal iskeyword=39,48-57,95,a-z,A-Z,192-255
    nnoremap <buffer> <Leader>l :<C-u>GhciLoad<CR>
    nnoremap <buffer> <Leader>i :<C-u>GhciInfo<CR>
    augroup haskell-bufwritepre
      autocmd BufWritePre <buffer>
            \   let s:cursor = getpos('.')
            \ | let s:view = winsaveview()
            \ | let s:start = search('^import')
            \ | let s:end = search('^\%(import\)\@!') - 1
            \ | if s:start > 0 && s:end > s:start
            \ |   execute s:start . ',' . s:end . 'sort'
            \ | endif
            \ | %s/\[Char\]/String/geI
            \ | call setpos('.', s:cursor)
            \ | call winrestview(s:view)
    augroup END
  pdf: |
    nmap <silent><buffer> <C-@> <C-t>
  haxe: |
    call tcomment#DefineType('haxe', '// %s')
  meissa: |
    call tcomment#DefineType('meissa', '# %s')
  spice: |
    call tcomment#DefineType('spice', '* %s')

filetypeDetect:
  bf: brainfuck
  gnuplot: gnuplot
  jade: jade
  json: json
  less: less
  sass: sass
  scss: scss
  r: r
  roy: roy
  meissa: meissa
  coffee: coffee
  litcoffee: litcoffee
  cson: coffee
  ts: typescript
  ejs: jst
  jst: jst
  hamljs: jst
  stl: stl
  cls: tex
  aux: tex
  toc: tex
  nav: tex
  clo: tex
  tex: tex
  hs: haskell
  hx: haxe
  md: markdown
  mkd: markdown
  markdown: markdown
  yaml: yaml
  CIR: spice
  cir: spice
  asc: spice
  m: objc
  styl: stylus
  stylus: stylus
  scala: scala
  sbt: scala
